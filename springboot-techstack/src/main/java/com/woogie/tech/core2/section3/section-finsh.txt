정리
이번엔 변하는 코드와 변하지 않는 코드를 분리하고, 더 적은 코드로 로그 추적기를 적용하였다.
템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴까지 진행하면서 변하는코드, 변하지않는코드로 분리하였다.
최종적으로 템플릿 콜백 패턴을 적용하여 콜백으로 람다를 사용해서 코드사용도 최소화로 만들어보았다.

하지만 지금까지 설명한 방식의 한계는 아무리 최적화를 해도 결국 로그 추적기를 적용하기 위해서 원본 코드를 수정해야한다는 점이다.
클래스가 수백개면 수백개를 더힘들게 수정하는가? 더힘든것을 덜힘들게 수정하는가의 차이일뿐인것이다. 본질적으로 코드를 다 수정해야하는것은
마찬가지이다.

결국 원본코드를 손대지 않고 로그 추적기를 적용할수있는 방법에대해서 알아봐도록 해보자 그것을 알기위해서는 프록시 개념부터 이해해야한다고
생각한다.

"참고"
지금까지 설명한 방식은 실제 스프링 안에서 많이 사용되는 방식이다. "XXXTemplate"를 만난다면 이번에 학습한 내용을 떠올리면서
어떻게 돌아가는지 쉽게 이해할수 있을것이다.

======================================================

템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴은 아무리 최적화를 해도 결국 로그 추적기를 적용하기위해서 원본 코드를 수정해야 한다는 점이다
지금부터 원본 코드를 손대지않고 로그 추적기를 적용할수있는 방법을 알아두자. 그 전에 프록시라는 개념을 알아두자

템플릿 메서드 패턴
부모 클래스에 템플릿을 넣어 자식 클래스에 상속을 받아 사용한다
다형성으로 변하지않는부분은 부모클래스, 변하는 부분은 자식클래스를 사용헀다.
단점 : 부모 코드에서 코드가 바뀌면 자식 클래스 영향을 받는다, 자식클래스는 부모 클래스를 사용하지않는데 의존을 하는게 모순이다.

전략 패턴
상속받는개념이 아닌 위임(컴포지션)으로 해결을한다
Context가 Template역할(변하지않는부분), Strategy가 변하는부분이다.
1. 먼저 context에게 의존관계 주입을 하고 난후,그 다음 실행
2. 의존관계 주입을하지않고, parameter에게 값을 넘기고 그 다음실행 (전략을 그대로 넘겨버리는 행위)
3. 큰 템플릿이 존재하고, 어떤 특정 조각만 그 템플릿안에서 실행되게하고 그리고 그 템플릿에게 조각을 던지는 행위 = 템플릿 콜백 패턴

