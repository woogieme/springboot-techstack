템플릿 메서드 패턴은 부모 클래스에 변하지않는 템플릿을 두고, 변하는 부분을 자식 클래스에 두어서 상속을 사용하여 문제를 해결했다.
전략 패턴은 변하지 않을 부분을 `context`라는 곳에 두고, 변하는 부분을 Strategy 라는 인터페이스를 만들고 해당 인터페이스를
구현하도록 해서 문제를 해결한다
즉, 상속이 아닌 위임으로 해결한다.
전략 패턴에선 Context는 변하지 않는 템플릿 역할을하고, Strategy는 변하는 알고리즘 역할을 한다.

GOF디자인 패턴에서 정의한 전략패턴 의도?
알고리즘 제품군을 정의하고 각각을 캡슐화하여 상호 교환 가능하게 만들자 전략을 사용하면 알고리즘을 사용하는 클라이언트와 독립적으로
알고리즘을 변경할 수 있다.

익명 내부 클래스는 자바8부터 제공하는 람다로 변경할수있다. 람다로 변경하려면 인터페이스에 메서드가 1개만있으면 되는데,
여기에서 제공하는 Strategy 인터페이스는 메서드가 1개만 있으므로 람다로 사용할 수있다.
람다에 대한 부분은 자바 기분 문법이므로 자바 문법 관련 내용을 찾아보자.

선 조립, 후 실행
Context의 내부 필드에 Strategy를 두고 사용하는 부분을 지칭하는말이다
이 방식은 Context와 Startegy를 한번 조립하고나면 이후로는 Context를 실행하기만 하면 된다. 우리가 스프링으로 애플리케이션을
개발할 떄 애플리케이션 로딩 시점에 의존관계 주입을 통해 필요한 의존관계를 모두 맺어두고 난 다음에 실제 요청을 처리하는것과 같은
원리이다.

이 방식의 단점은 Context와 Strategy를 조립한 이후에는 전략을 변경하기가 쉽지 않다는것이다.
Context를 싱글톤으로 사용할때에는 동시성 이슈 등 고려할 점이 많다. 전략을 실시간으로 변경해야한다면 Context를 하나 더 생성하고
그곳에 다른 Strategy를 주입하는 것이 더 나을수 있다.

전략 패턴에 2가지 방식이 있는데
1. 의존성 주입에 의한 전략 패턴
2. 파라미터로 주입하는 전략 패턴
즉, 이제 context strategy를 선조립 후실행 방식이아닌 context실행할때마다 전략을 인수로 전달하는거다.
클라이언트는 context를 실행하는 시점에 내가 원하는 strategy를 전달할수있는 장점이 존재한다.(내가원할때 값을준다)
=> 이전 방식과 다르게 유연하게 전략을 변경할수있다.
TestCode를 보면 하나의 Context를 만드는것도 장점인데, 하나의 컨텍스트의 실행시점에서 여러 전략을 전달해서  유연하게 실행하는것을
확인할수있다.
클라이언트 = Test Cocde